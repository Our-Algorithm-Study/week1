# -*- coding: utf-8 -*-
"""kyungbin(2/11).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QVeyucfwX3xvUKg0EgZzVfiuB8RXPuKK
"""

# A + B

A, B = map(int,input().split())
print(A + B)

# 시험성적

score = int(input())
if score >= 90:
    print("A")
elif score >= 80:
    print("B")
elif score >= 70:
    print("C")
elif score >= 60:
    print("D")
else:
    print("F")

#주사위 3개

first, second, thord = map(int,input().split())
if first == second == thord:
    print(10000 + first * 1000)
elif first == second or first == thord:
    print(1000 + first * 100)
elif second == thord:
    print(1000 + second * 100)
else:
    print(max(first, second, thord) * 100)

#바구니 뒤집기
#인데스 범위만큼 분리한 후 역순으로 정렬, 그 후 다시 원래 리스트에 끼워넣기
N, M = map(int,input().split())

lst = list(range(1,N+1))

for i in range(M):
  i, j = map(int, input().split())
  fix = lst[i-1 : j]
  fix.reverse()
  lst[i-1 : j] = fix

print(*lst)

#벌집 (틀린ver)
#방정식을 세우려 했는데, 안됨

N = int(input())

room = (N - 1) // 6 + 1
if (N - 1) % 6 != 0:
    room += 1

print(room)

#벌집
#일반적 풀이
# num가 1일 때 room_num을 1로 배정해줌
# room_num가 커지는 규칙이 존재함
# N이 주어지면 그 규칙을 몇번 돌아야 하는 지로 판별
N = int(input())

num, room_num = 1, 1

while N > num :
  num += 6 * room_num
  room_num +=1

print(room_num)

#소수 찾기
#일반적으로 최대한 짧게 할 수 있는 방법
N = int(input())
num = list(map(int, input().split()))

count = 0

for a in num:
  if a < 2:
    continue


  prime = True
  for b in range(2, a):
    if a % b == 0:
      prime = False
      break

  if prime :
    count += 1

print(count)

# 소수 찾기
# 에라토스테네스의 체보다 많이 사용하는 소수 판별법
# 약수집합들은 항상 대칭성을 지님 ->ex) (1, 4) (2,2) (4,1)
#                                   ex) (1, 18) (2, 9) (3, 6) (6, 3) (9, 2) (1. 18)
# 우리는 끝까지 다 볼 필요가 없음

N = int(input())
num = list(map(int, input().split()))

count = 0

for a in num:
    if a < 2:
        continue

    prime = True
    for b in range(2, int(a**0.5) + 1):
        if a % b == 0:
            prime = False
            break

    if prime:
        count += 1

print(count)

# 설탕 배달
#최대한 5kg짜리를 써보고 안되면 3kg빼기

N = int(input())

bag = 0
while N >= 0:
  if N % 5 == 0:
    bag += N//5
    print(count)
    break
  N -= 3
  bag +=1

else:
  print(-1)

# 좌표 정렬하기 2
#파이썬 정렬할 때는 그냥 sort함수 쓰는게 가장 정배임
# sort함수는 좌표끼리 비교할 때, 앞의 값부터 고려하고 앞의 값이 같을 때 뒤의 값을 고려한다는 점을 이용
n = int(input())
array = []
for i in range(n):
    x, y = map(int, input().split())
    array.append([y, x])

s_array = sorted(array)

for x, y in s_array:
  print(y, x)

# 숫자 카드
# 처음 든 생각
# 1. 일일이 비교하면 시간이 너무 오래 걸리겠다.
# 2. 같은 수는 절대 나오지 않으니, 집합을 사용하면 시간을 줄일 수 있겠다.
# 3. 교집합을 사용하려 했는데 교집합이 출력된걸 다시 0,1로 변환하는 것이 어려움
# 4. 추가 아이디어 -> 애초에 나한테 가장 작은 수보다 작은수가 있으면 0 반대도 0 (결국 불필요)


N = int(input())
card = set(map(int, input().split()))

M = int(input())
compare = list(map(int, input().split()))
#처음에는 set로 저장했는데, 그러면 일일이 비교할 수가 없다.

result = []

for i in compare:
  if i in card:
    result.append(1)
  else:
    result.append(0)

print(*result)

# 듣보잡

# 처음 든 생각 위의 문제와 같이 set로 저장할까?
# 왜냐하면 set는 교집합을 이용할 수 있음


N, M = map(int, input().split())

deaf = set()
for i in range(N):
  name = input()
  deaf.add(name)

blind = set()
for i in range(M):
  name = input()
  blind.add(name)

deafandblind = deaf & blind
print(len(deafandblind))
for name in sorted(deafandblind):
  print(name)